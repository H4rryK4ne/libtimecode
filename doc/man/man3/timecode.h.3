.TH "timecode.h" 3 "Thu Nov 1 2012" "Version 0.5.0" "libtimecode" \" -*- nroff -*-
.ad l
.nh
.SH NAME
timecode.h \- 
.PP
libtimecode - convert A/V timecode and framerate  

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBTimecodeTime\fP"
.br
.ti -1c
.RI "struct \fBTimecodeDate\fP"
.br
.ti -1c
.RI "struct \fBTimecodeRate\fP"
.br
.ti -1c
.RI "struct \fBTimecode\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTCFPS23976\fP   (&\fBtcfps23976\fP)"
.br
.ti -1c
.RI "#define \fBTCFPS24\fP   (&\fBtcfps24\fP)"
.br
.ti -1c
.RI "#define \fBTCFPS24976\fP   (&\fBtcfps24976\fP)"
.br
.ti -1c
.RI "#define \fBTCFPS25\fP   (&\fBtcfps25\fP)"
.br
.ti -1c
.RI "#define \fBTCFPS2997DF\fP   (&\fBtcfps2997df\fP)"
.br
.ti -1c
.RI "#define \fBTCFPS30\fP   (&\fBtcfps30\fP)"
.br
.ti -1c
.RI "#define \fBTCFPSMS\fP   (&\fBtcfpsMS\fP)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBint32_t\fP"
.br
.ti -1c
.RI "typedef long long int \fBint64_t\fP"
.br
.ti -1c
.RI "typedef struct \fBTimecodeTime\fP \fBTimecodeTime\fP"
.br
.ti -1c
.RI "typedef struct \fBTimecodeDate\fP \fBTimecodeDate\fP"
.br
.ti -1c
.RI "typedef struct \fBTimecodeRate\fP \fBTimecodeRate\fP"
.br
.ti -1c
.RI "typedef struct \fBTimecode\fP \fBTimecode\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBtimecode_rate_to_double\fP (\fBTimecodeRate\fP const *const r)"
.br
.ti -1c
.RI "double \fBtimecode_frames_per_timecode_frame\fP (\fBTimecodeRate\fP const *const r, const double samplerate)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBtimecode_to_sample\fP (\fBTimecodeTime\fP const *const t, \fBTimecodeRate\fP const *const r, const double samplerate)"
.br
.ti -1c
.RI "void \fBtimecode_sample_to_time\fP (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r, const double samplerate, const \fBint64_t\fP sample)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBtimecode_to_framenumber\fP (\fBTimecodeTime\fP const *const t, \fBTimecodeRate\fP const *const r)"
.br
.ti -1c
.RI "void \fBtimecode_framenumber_to_time\fP (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r, const \fBint64_t\fP frameno)"
.br
.ti -1c
.RI "void \fBtimecode_convert_rate\fP (\fBTimecodeTime\fP *const t_out, \fBTimecodeRate\fP const *const r_out, \fBTimecodeTime\fP *const t_in, \fBTimecodeRate\fP const *const r_in)"
.br
.ti -1c
.RI "double \fBtimecode_sample_to_seconds\fP (const \fBint64_t\fP sample, double samplerate)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBtimecode_seconds_to_sample\fP (const double sec, double samplerate)"
.br
.ti -1c
.RI "double \fBtimecode_framenumber_to_seconds\fP (const \fBint64_t\fP frameno, \fBTimecodeRate\fP const *const r)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBtimecode_seconds_to_framenumber\fP (const double sec, \fBTimecodeRate\fP const *const r)"
.br
.ti -1c
.RI "void \fBtimecode_seconds_to_time\fP (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r, const double sec)"
.br
.ti -1c
.RI "double \fBtimecode_to_sec\fP (\fBTimecodeTime\fP const *const t, \fBTimecodeRate\fP const *const r)"
.br
.ti -1c
.RI "void \fBtimecode_time_add\fP (\fBTimecodeTime\fP *const res, \fBTimecodeRate\fP const *const r, \fBTimecodeTime\fP const *const t1, \fBTimecodeTime\fP const *const t2)"
.br
.ti -1c
.RI "void \fBtimecode_time_subtract\fP (\fBTimecodeTime\fP *const res, \fBTimecodeRate\fP const *const r, \fBTimecodeTime\fP const *const t1, \fBTimecodeTime\fP const *const t2)"
.br
.ti -1c
.RI "int \fBtimecode_time_compare\fP (\fBTimecodeRate\fP const *const r, \fBTimecodeTime\fP const *const a, \fBTimecodeTime\fP const *const b)"
.br
.ti -1c
.RI "int \fBtimecode_date_compare\fP (\fBTimecodeDate\fP const *const a, \fBTimecodeDate\fP const *const b)"
.br
.ti -1c
.RI "int \fBtimecode_datetime_compare\fP (\fBTimecodeRate\fP const *const r, \fBTimecode\fP const *const a, \fBTimecode\fP const *const b)"
.br
.ti -1c
.RI "void \fBtimecode_date_increment\fP (\fBTimecodeDate\fP *const d)"
.br
.ti -1c
.RI "void \fBtimecode_date_decrement\fP (\fBTimecodeDate\fP *const d)"
.br
.ti -1c
.RI "int \fBtimecode_time_increment\fP (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r)"
.br
.ti -1c
.RI "int \fBtimecode_time_decrement\fP (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r)"
.br
.ti -1c
.RI "int \fBtimecode_datetime_increment\fP (\fBTimecode\fP *const dt)"
.br
.ti -1c
.RI "int \fBtimecode_datetime_decrement\fP (\fBTimecode\fP *const dt)"
.br
.ti -1c
.RI "void \fBtimecode_time_to_string\fP (char *smptestring, \fBTimecodeTime\fP const *const t)"
.br
.ti -1c
.RI "size_t \fBtimecode_strftimecode\fP (char *str, const size_t maxsize, const char *format, const \fBTimecode\fP const *const t)"
.br
.ti -1c
.RI "size_t \fBtimecode_strftime\fP (char *str, const size_t maxsize, const char *format, const \fBTimecodeTime\fP const *const t, const \fBTimecodeRate\fP const *const r)"
.br
.ti -1c
.RI "void \fBtimecode_parse_time\fP (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r, const char *val)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps23976\fP = { 24000, 1001, 0, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps24\fP = { 24, 1, 0, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps24976\fP = { 25000, 1001, 0, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps25\fP = { 25, 1, 0, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps2997ndf\fP = { 30000, 1001, 0, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps2997df\fP = { 30000, 1001, 1, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps30\fP = { 30, 1, 0, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps30df\fP = { 30, 1, 1, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps5994\fP = { 60000, 1001, 0, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfps60\fP = { 30, 1, 0, 80}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfpsDS\fP = { 10, 1, 0, 1000}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfpsCS\fP = { 100, 1, 0, 1000}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfpsMS\fP = { 1000, 1, 0, 1000}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfpsUS\fP = { 1000000, 1, 0, 1}"
.br
.ti -1c
.RI "const \fBTimecodeRate\fP \fBtcfpsNS\fP = {1000000000, 1, 0, 1}"
.br
.in -1c
.SH "Detailed Description"
.PP 
libtimecode - convert A/V timecode and framerate 

\fBAuthor:\fP
.RS 4
Robin Gareus robin@gareus.org
.RE
.PP
Copyright (C) 2006, 2007, 2008, 2012 Robin Gareus robin@gareus.org
.PP
This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser Public License as published by the Free Software Foundation; either version 3, or (at your option) any later version\&.
.PP
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE\&. See the GNU Lesser Public License for more details\&.
.PP
You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc\&., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 
.SH "Data Structure Documentation"
.PP 
.SH "struct TimecodeTime"
.PP 
classical timecode 
.PP
\fBData Fields:\fP
.RS 4
\fBint32_t\fP \fIframe\fP timecode frames 0\&.\&.fps 
.br
.PP
\fBint32_t\fP \fIhour\fP timecode hours 0\&.\&.24 
.br
.PP
\fBint32_t\fP \fIminute\fP timecode minutes 0\&.\&.59 
.br
.PP
\fBint32_t\fP \fIsecond\fP timecode seconds 0\&.\&.59 
.br
.PP
\fBint32_t\fP \fIsubframe\fP timecode subframes 0\&.\&. 
.br
.PP
.RE
.PP
.SH "struct TimecodeDate"
.PP 
date and timezone 
.PP
\fBData Fields:\fP
.RS 4
\fBint32_t\fP \fIday\fP day of month 0\&.\&.31 
.br
.PP
\fBint32_t\fP \fImonth\fP month 1\&.\&.12 
.br
.PP
\fBint32_t\fP \fItimezone\fP minutes west of UTC +1245 (Chatham Island) \&.\&. -1200 (Kwaialein); LA: -0800, NYC: -0500, Paris: +0100, Bombay: +0530, Tokyo: +0900 
.br
.PP
\fBint32_t\fP \fIyear\fP year A\&.D\&. 4 digits 
.br
.PP
.RE
.PP
.SH "struct TimecodeRate"
.PP 
define a frame rate 
.PP
\fBData Fields:\fP
.RS 4
\fBint32_t\fP \fIden\fP fps denominator 
.br
.PP
int \fIdrop\fP 1: use drop-frame timecode (only valid for 2997/100) 
.br
.PP
\fBint32_t\fP \fInum\fP fps numerator 
.br
.PP
\fBint32_t\fP \fIsubframes\fP number of subframes per frame 
.br
.PP
.RE
.PP
.SH "struct Timecode"
.PP 
complete date time description incl frame rate 
.PP
\fBData Fields:\fP
.RS 4
\fBTimecodeDate\fP \fId\fP date MM/DD/YYYY + Timezone 
.br
.PP
\fBTimecodeRate\fP \fIr\fP the frame rate used for \fBTimecodeTime\fP 
.br
.PP
\fBTimecodeTime\fP \fIt\fP timecode HH:MM:SS:FF\&.SSS 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define TCFPS23976   (&\fBtcfps23976\fP)"

.SS "#define TCFPS24   (&\fBtcfps24\fP)"

.SS "#define TCFPS24976   (&\fBtcfps24976\fP)"

.SS "#define TCFPS25   (&\fBtcfps25\fP)"

.SS "#define TCFPS2997DF   (&\fBtcfps2997df\fP)"

.SS "#define TCFPS30   (&\fBtcfps30\fP)"

.SS "#define TCFPSMS   (&\fBtcfpsMS\fP)"

.SH "Typedef Documentation"
.PP 
.SS "typedef int \fBint32_t\fP"

.SS "typedef long long int \fBint64_t\fP"

.SS "typedef struct \fBTimecode\fP  \fBTimecode\fP"
complete date time description incl frame rate 
.SS "typedef struct \fBTimecodeDate\fP  \fBTimecodeDate\fP"
date and timezone 
.SS "typedef struct \fBTimecodeRate\fP  \fBTimecodeRate\fP"
define a frame rate 
.SS "typedef struct \fBTimecodeTime\fP  \fBTimecodeTime\fP"
classical timecode 
.SH "Function Documentation"
.PP 
.SS "void timecode_convert_rate (\fBTimecodeTime\fP *const t_out, \fBTimecodeRate\fP const *const r_out, \fBTimecodeTime\fP *const t_in, \fBTimecodeRate\fP const *const r_in)"
convert timecode from one rate to another\&.
.PP
Note: if t_out points to the same timecode as t_in, the timecode will be modified\&.
.PP
\fBParameters:\fP
.RS 4
\fIt_out\fP [output] timecode t_in converted to frame rate r_out 
.br
\fIr_out\fP frame rate to convert to 
.br
\fIt_in\fP the timecode to convert (may be identical to t_out) 
.br
\fIr_in\fP the frame rate of the timecode to convert from 
.RE
.PP

.SS "int timecode_date_compare (\fBTimecodeDate\fP const *const a, \fBTimecodeDate\fP const *const b)"
The \fBtimecode_date_compare()\fP function compares the two dates a and b\&. It returns an integer less than, equal to, or greater than zero if a is found, respectively, to be later than, to match, or be earlier than b\&.
.PP
\fBParameters:\fP
.RS 4
\fIa\fP date to compare 
.br
\fIb\fP date to compare 
.RE
.PP
\fBReturns:\fP
.RS 4
+1 if a is later than b, -1 if a is earlier than b, 0 if timecodes are equal 
.RE
.PP

.SS "void timecode_date_decrement (\fBTimecodeDate\fP *const d)"
decrement date by one day\&. Note: this function honors leap-years\&. 
.PP
\fBParameters:\fP
.RS 4
\fId\fP the date to adjust 
.RE
.PP

.SS "void timecode_date_increment (\fBTimecodeDate\fP *const d)"
increment date by one day\&. Note: This function honors leap-years\&. 
.PP
\fBParameters:\fP
.RS 4
\fId\fP the date to adjust 
.RE
.PP

.SS "int timecode_datetime_compare (\fBTimecodeRate\fP const *const r, \fBTimecode\fP const *const a, \fBTimecode\fP const *const b)"
The \fBtimecode_datetime_compare()\fP function compares the two datetimes a and b\&. It returns an integer less than, equal to, or greater than zero if a is found, respectively, to be later than, to match, or be earlier than b\&.
.PP
This function is a wrapper around \fBtimecode_time_compare\fP and \fBtimecode_date_compare\fP it includes additional functionality to handle timezones correctly\&.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP frame rate to use for both a and b 
.br
\fIa\fP timecode to compare (using frame rate r) 
.br
\fIb\fP timecode to compare (using frame rate r) 
.RE
.PP
\fBReturns:\fP
.RS 4
+1 if a is later than b, -1 if a is earlier than b, 0 if timecodes are equal 
.RE
.PP

.SS "int timecode_datetime_decrement (\fBTimecode\fP *const dt)"
increment datetime by one frame this is a wrapper function around \fBtimecode_date_increment\fP and \fBtimecode_time_increment\fP 
.PP
\fBParameters:\fP
.RS 4
\fIdt\fP the datetime to modify 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if timecode wrapped 24 hours, 0 otherwise 
.RE
.PP

.SS "int timecode_datetime_increment (\fBTimecode\fP *const dt)"
increment datetime by one frame this is a wrapper function around \fBtimecode_date_increment\fP and \fBtimecode_time_increment\fP 
.PP
\fBParameters:\fP
.RS 4
\fIdt\fP the datetime to modify 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if timecode wrapped 24 hours, 0 otherwise 
.RE
.PP

.SS "double timecode_framenumber_to_seconds (const \fBint64_t\fP frameno, \fBTimecodeRate\fP const *const r)"
convert frame number to floating point seconds
.PP
\fBParameters:\fP
.RS 4
\fIframeno\fP frame number (starting at zero) 
.br
\fIr\fP frame rate 
.RE
.PP
\fBReturns:\fP
.RS 4
seconds 
.RE
.PP

.SS "void timecode_framenumber_to_time (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r, const \fBint64_t\fP frameno)"
convert video frame-number to timecode
.PP
this function simply calls \fBtimecode_framenumber_to_time\fP with the sample rate set to the fps\&.
.PP
\fBParameters:\fP
.RS 4
\fIt\fP [output] the timecode that corresponds to the frame 
.br
\fIr\fP frame rate to use for conversion 
.br
\fIframeno\fP the frame-number to convert 
.RE
.PP

.SS "double timecode_frames_per_timecode_frame (\fBTimecodeRate\fP const *const r, const double samplerate)"
calculate samples per timecode-frame for a given sample rate: (samplerate * r->num / r->den)\&.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP frame rate to convert 
.br
\fIsamplerate\fP the sampling rate 
.RE
.PP
\fBReturns:\fP
.RS 4
number of samples per timecode-frame\&. 
.RE
.PP

.SS "void timecode_parse_time (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r, const char * val)"
parse string to timecode time - separators may include ':\&.;' the format is '[[[HH:]MM:]SS:]FF', subframes are set to 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIt\fP [output] the parsed timecode 
.br
\fIr\fP frame rate to use 
.br
\fIval\fP the value to parse 
.RE
.PP

.SS "double timecode_rate_to_double (\fBTimecodeRate\fP const *const r)"
convert rational frame rate to double (r->num / r->den)\&.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP frame rate to convert 
.RE
.PP
\fBReturns:\fP
.RS 4
double representation of frame rate 
.RE
.PP

.SS "double timecode_sample_to_seconds (const \fBint64_t\fP sample, double samplerate)"
convert sample number to floating point seconds
.PP
\fBParameters:\fP
.RS 4
\fIsample\fP sample number (starting at zero) 
.br
\fIsamplerate\fP sample rate 
.RE
.PP
\fBReturns:\fP
.RS 4
seconds 
.RE
.PP

.SS "void timecode_sample_to_time (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r, const double samplerate, const \fBint64_t\fP sample)"
convert audio sample number to timecode
.PP
NB\&. this function can also be used to convert integer milli-seconds or micro-seconds by specifying a sample rate of 1000 or 10^6 respectively\&.
.PP
When used with samplerate == \fBtimecode_rate_to_double\fP this function can also convert video-frame number to timecode\&.
.PP
\fBParameters:\fP
.RS 4
\fIt\fP [output] the timecode that corresponds to the sample 
.br
\fIr\fP frame rate to use for conversion 
.br
\fIsamplerate\fP the sample rate the sample was taken at 
.br
\fIsample\fP the audio sample number to convert 
.RE
.PP

.SS "\fBint64_t\fP timecode_seconds_to_framenumber (const double sec, \fBTimecodeRate\fP const *const r)"
convert floating-point seconds to timecode frame number at given frame rate\&. Opposed to \fBtimecode_seconds_to_sample\fP which rounds the sample number to the nearest sample, this function always rounds down to the current frame\&.
.PP
\fBParameters:\fP
.RS 4
\fIsec\fP seconds 
.br
\fIr\fP frame rate 
.RE
.PP
\fBReturns:\fP
.RS 4
sample number (starting at zero) 
.RE
.PP

.SS "\fBint64_t\fP timecode_seconds_to_sample (const double sec, double samplerate)"
convert floating-point seconds to nearest sample number at given sample rate\&.
.PP
\fBParameters:\fP
.RS 4
\fIsec\fP seconds 
.br
\fIsamplerate\fP sample rate 
.RE
.PP
\fBReturns:\fP
.RS 4
sample number (starting at zero) 
.RE
.PP

.SS "void timecode_seconds_to_time (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r, const double sec)"
convert floating point seconds to timecode\&.
.PP
uses \fBtimecode_sample_to_time\fP and \fBtimecode_seconds_to_sample\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIt\fP [output] the timecode that corresponds to the sample 
.br
\fIr\fP frame rate to use for conversion 
.br
\fIsec\fP seconds to convert 
.RE
.PP

.SS "size_t timecode_strftime (char * str, const size_t maxsize, const char * format, const \fBTimecodeTime\fP const *const t, const \fBTimecodeRate\fP const *const r)"
wrapper around \fBtimecode_strftimecode\fP for formatting timecode time\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP [output] formatted string str (must be large enough)\&. 
.br
\fImaxsize\fP write at most maxsize bytes (including the trailing null byte ('\\0')) to str 
.br
\fIformat\fP the format directive 
.br
\fIt\fP the timecode time to format 
.br
\fIr\fP optional framerate (may be NULL) 
.RE
.PP
\fBReturns:\fP
.RS 4
number of bytes written to str 
.RE
.PP

.SS "size_t timecode_strftimecode (char * str, const size_t maxsize, const char * format, const \fBTimecode\fP const *const t)"
print formatted timecode to text string\&.
.PP
TODO format documentation\&.\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP [output] formatted string str (must be large enough)\&. 
.br
\fImaxsize\fP write at most maxsize bytes (including the trailing null byte ('\\0')) to str 
.br
\fIformat\fP the format directive 
.br
\fIt\fP the timecode to format 
.RE
.PP
\fBReturns:\fP
.RS 4
number of bytes written to str 
.RE
.PP

.SS "void timecode_time_add (\fBTimecodeTime\fP *const res, \fBTimecodeRate\fP const *const r, \fBTimecodeTime\fP const *const t1, \fBTimecodeTime\fP const *const t2)"
add two timecodes at same frame rate\&.
.PP
Note: res, t1 and t2 may all point to the same structure\&.
.PP
\fBParameters:\fP
.RS 4
\fIres\fP [output] result of addition 
.br
\fIr\fP frame rate 
.br
\fIt1\fP first summand 
.br
\fIt2\fP second summand 
.RE
.PP

.SS "int timecode_time_compare (\fBTimecodeRate\fP const *const r, \fBTimecodeTime\fP const *const a, \fBTimecodeTime\fP const *const b)"
The \fBtimecode_time_compare()\fP function compares the two timecodes a and b\&. It returns an integer less than, equal to, or greater than zero if a is found, respectively, to be later than, to match, or be earlier than b\&.
.PP
\fBParameters:\fP
.RS 4
\fIr\fP frame rate to use for both a and b 
.br
\fIa\fP timecode to compare (using frame rate r) 
.br
\fIb\fP timecode to compare (using frame rate r) 
.RE
.PP
\fBReturns:\fP
.RS 4
+1 if a is later than b, -1 if a is earlier than b, 0 if timecodes are equal 
.RE
.PP

.SS "int timecode_time_decrement (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r)"
decrement timecode by one frame\&. 
.PP
\fBParameters:\fP
.RS 4
\fIt\fP the timecode to modify 
.br
\fIr\fP frame rate to use 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if timecode wrapped 24 hours, 0 otherwise 
.RE
.PP

.SS "int timecode_time_increment (\fBTimecodeTime\fP *const t, \fBTimecodeRate\fP const *const r)"
increment timecode by one frame\&. 
.PP
\fBParameters:\fP
.RS 4
\fIt\fP the timecode to modify 
.br
\fIr\fP frame rate to use 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if timecode wrapped 24 hours, 0 otherwise 
.RE
.PP

.SS "void timecode_time_subtract (\fBTimecodeTime\fP *const res, \fBTimecodeRate\fP const *const r, \fBTimecodeTime\fP const *const t1, \fBTimecodeTime\fP const *const t2)"
subtract timecode at same frame rate\&.
.PP
Note: res, t1 and t2 may all point to the same structure\&.
.PP
\fBParameters:\fP
.RS 4
\fIres\fP [output] difference between t1 and t2: (t1-t2) 
.br
\fIr\fP frame rate 
.br
\fIt1\fP minuend 
.br
\fIt2\fP subtrahend 
.RE
.PP

.SS "void timecode_time_to_string (char * smptestring, \fBTimecodeTime\fP const *const t)"
format timecode as string 'HH:MM:SS:FF'\&.
.PP
\fBParameters:\fP
.RS 4
\fIsmptestring\fP [output] formatted string, must be at least 12 bytes long\&. 
.br
\fIt\fP the timecode to print 
.RE
.PP

.SS "\fBint64_t\fP timecode_to_framenumber (\fBTimecodeTime\fP const *const t, \fBTimecodeRate\fP const *const r)"
convert timecode to frame number
.PP
this function simply calls \fBtimecode_to_sample\fP with the samplerate set to the fps\&.
.PP
\fBParameters:\fP
.RS 4
\fIt\fP the timecode to convert 
.br
\fIr\fP frame rate to use for conversion 
.RE
.PP
\fBReturns:\fP
.RS 4
frame-number 
.RE
.PP

.SS "\fBint64_t\fP timecode_to_sample (\fBTimecodeTime\fP const *const t, \fBTimecodeRate\fP const *const r, const double samplerate)"
convert timecode to audio sample number
.PP
NB\&. this function can also be used to convert integer milli-seconds or micro-seconds by specifying a sample rate of 1000 or 10^6 respectively\&.
.PP
When used with samplerate == \fBtimecode_rate_to_double\fP this function can also convert timecode to video-frame number\&.
.PP
\fBParameters:\fP
.RS 4
\fIt\fP the timecode to convert 
.br
\fIr\fP frame rate to use for conversion 
.br
\fIsamplerate\fP the sample rate the sample was taken at 
.RE
.PP
\fBReturns:\fP
.RS 4
audio sample number 
.RE
.PP

.SS "double timecode_to_sec (\fBTimecodeTime\fP const *const t, \fBTimecodeRate\fP const *const r)"
convert timecode to floating point seconds\&.
.PP
uses \fBtimecode_sample_to_seconds\fP and \fBtimecode_to_sample\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIt\fP the timecode to convert 
.br
\fIr\fP frame rate 
.RE
.PP
\fBReturns:\fP
.RS 4
seconds 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const \fBTimecodeRate\fP tcfps23976 = { 24000, 1001, 0, 80}"

.SS "const \fBTimecodeRate\fP tcfps24 = { 24, 1, 0, 80}"

.SS "const \fBTimecodeRate\fP tcfps24976 = { 25000, 1001, 0, 80}"

.SS "const \fBTimecodeRate\fP tcfps25 = { 25, 1, 0, 80}"

.SS "const \fBTimecodeRate\fP tcfps2997df = { 30000, 1001, 1, 80}"

.SS "const \fBTimecodeRate\fP tcfps2997ndf = { 30000, 1001, 0, 80}"

.SS "const \fBTimecodeRate\fP tcfps30 = { 30, 1, 0, 80}"

.SS "const \fBTimecodeRate\fP tcfps30df = { 30, 1, 1, 80}"

.SS "const \fBTimecodeRate\fP tcfps5994 = { 60000, 1001, 0, 80}"

.SS "const \fBTimecodeRate\fP tcfps60 = { 30, 1, 0, 80}"

.SS "const \fBTimecodeRate\fP tcfpsCS = { 100, 1, 0, 1000}"

.SS "const \fBTimecodeRate\fP tcfpsDS = { 10, 1, 0, 1000}"

.SS "const \fBTimecodeRate\fP tcfpsMS = { 1000, 1, 0, 1000}"

.SS "const \fBTimecodeRate\fP tcfpsNS = {1000000000, 1, 0, 1}"

.SS "const \fBTimecodeRate\fP tcfpsUS = { 1000000, 1, 0, 1}"

.SH "Author"
.PP 
Generated automatically by Doxygen for libtimecode from the source code\&.
